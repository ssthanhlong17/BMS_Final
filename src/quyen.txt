float updateSOC(float current_A, float temperature_C, unsigned long now_ms) {
    
    // 1. TÃ­nh Î”t (s)
    float dt_sec = (now_ms - lastUpdate_ms) / 1000.0f;
    lastUpdate_ms = now_ms;

    // 2. TÃ­nh Ä‘iá»‡n lÆ°á»£ng thay Ä‘á»•i Î”Q (mAh)
    float deltaQ_mAh = current_A * 1000.0f * (dt_sec / 3600.0f);

    // 3. Cáº­p nháº­t bá»™ Ä‘áº¿m Coulomb
    coulombCounter_mAh += deltaQ_mAh;

    // 4. BÃ¹ nhiá»‡t Ä‘á»™ vÃ o dung lÆ°á»£ng hiá»‡u dá»¥ng
    float coeff = alphaTemperature(temperature_C);
    float effectiveCapacity_mAh = nominalCapacity_mAh * coeff;

    // 5. TÃ­nh SOC
    float soc = (coulombCounter_mAh / effectiveCapacity_mAh) * 100.0f;

    // Giá»›i háº¡n 0â€“100%
    if (soc < 0) soc = 0;
    if (soc > 100) soc = 100;

    return soc;
}


#ifndef SOC_ESTIMATOR_H
#define SOC_ESTIMATOR_H

#include <Arduino.h>

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  SOC ESTIMATOR for LiFePO4 4S Battery Pack
 *  
 *  Method: Hybrid approach
 *  - OCV lookup for initial SOC
 *  - Coulomb counting for realtime tracking
 *  - Temperature compensation (on usable capacity)
 *  - Automatic recalibration at full/empty states
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

class SOCEstimator {
private:
    // ==================== THÃ”NG Sá» PIN ====================
    const float CAPACITY_AH;              // Dung lÆ°á»£ng pin (Ah)
    const float CAPACITY_MAH;             // Dung lÆ°á»£ng pin (mAh)
    
    // ==================== NGÆ¯á» NG HIá»†U CHá»ˆNH ====================
    const float V_FULL = 14.5f;           // Pack Ä‘áº§y: 3.625V/cell Ã— 4
    const float V_CHARGING = 14.6f;       // Pack Ä‘ang sáº¡c max: 3.65V/cell Ã— 4
    const float V_EMPTY = 9.0f;           // Pack cáº¡n: 2.25V/cell Ã— 4
    const float V_CUTOFF = 10.0f;         // Cut-off báº£o vá»‡: 2.5V/cell Ã— 4
    const float V_RECALIB_FULL = 14.0f;   // NgÆ°á»¡ng báº¯t Ä‘áº§u kiá»ƒm tra Ä‘áº§y
    const float V_RECALIB_EMPTY = 10.4f;  // NgÆ°á»¡ng báº¯t Ä‘áº§u kiá»ƒm tra cáº¡n
    const float I_IDLE_THRESHOLD = 0.3f;  // DÃ²ng idle (A)
    const float I_CHARGE_CUTOFF = 0.2f;   // NgÆ°á»¡ng cáº¯t sáº¡c (A)
    const float I_LOAD_THRESHOLD = 1.0f;  // NgÆ°á»¡ng load nhá» (A)
    const float CURRENT_DEADBAND = 0.05f; // Deadband loáº¡i bá» noise (A)
    
    // ==================== Báº¢NG OCV CHO LiFePO4 4S ====================
    // [SOC%, Voltage_Pack] - Láº¥y giÃ¡ trá»‹ giá»¯a cá»§a má»—i khoáº£ng Ã— 4 cells
    const float OCV_TABLE[11][2] = {
        {0,   9.00},    // 2.25V/cell (giá»¯a 2.0-2.5)
        {10,  11.80},   // 2.95V/cell (giá»¯a 2.9-3.0)
        {20,  12.60},   // 3.15V/cell (giá»¯a 3.1-3.2)
        {30,  12.90},   // 3.225V/cell (giá»¯a 3.2-3.25)
        {40,  13.10},   // 3.275V/cell (giá»¯a 3.25-3.3)
        {50,  13.30},   // 3.325V/cell (giá»¯a 3.3-3.35)
        {60,  13.50},   // 3.375V/cell (giá»¯a 3.35-3.4)
        {70,  13.70},   // 3.425V/cell (giá»¯a 3.4-3.45)
        {80,  13.90},   // 3.475V/cell (giá»¯a 3.45-3.5)
        {90,  14.10},   // 3.525V/cell (giá»¯a 3.5-3.55)
        {100, 14.50}    // 3.625V/cell (giá»¯a 3.6-3.65)
    };
    
    // ==================== Báº¢NG BÃ™ NHIá»†T Äá»˜ ====================
    // [TemperatureÂ°C, Capacity_Factor]
    // Theo datasheet LiFePO4: dung lÆ°á»£ng giáº£m á»Ÿ nhiá»‡t Ä‘á»™ tháº¥p
    const float TEMP_COMP_TABLE[5][2] = {
        {-20, 0.40},    // -20Â°C: 40% dung lÆ°á»£ng
        {-10, 0.60},    // -10Â°C: 60% dung lÆ°á»£ng
        {0,   0.85},    // 0Â°C:   85% dung lÆ°á»£ng
        {25,  1.00},    // 25Â°C:  100% dung lÆ°á»£ng (chuáº©n)
        {60,  0.98}     // 60Â°C:  98% dung lÆ°á»£ng
    };
    
    // ==================== BIáº¾N TRáº NG THÃI ====================
    float soc;                      // SOC hiá»‡n táº¡i (%)
    float coulombCounter_mAh;       // TÃ­ch lÅ©y Coulomb (mAh)
    unsigned long lastUpdateTime;   // Thá»i Ä‘iá»ƒm cáº­p nháº­t cuá»‘i (ms)
    bool initialized;               // ÄÃ£ khá»Ÿi táº¡o SOC chÆ°a
    
    // Biáº¿n phá»¥ cho recalibration
    unsigned long idleStartTime;    // Thá»i Ä‘iá»ƒm báº¯t Ä‘áº§u idle
    bool isIdle;                    // Äang á»Ÿ tráº¡ng thÃ¡i idle
    
    // ==================== HÃ€M Ná»˜I Bá»˜ ====================
    
    /**
     * TÃ­nh SOC tá»« OCV báº±ng ná»™i suy tuyáº¿n tÃ­nh
     */
    float ocvToSOC(float voltage) {
        // Giá»›i háº¡n Ä‘iá»‡n Ã¡p
        if (voltage <= OCV_TABLE[0][1]) return 0.0f;
        if (voltage >= OCV_TABLE[10][1]) return 100.0f;
        
        // TÃ¬m khoáº£ng phÃ¹ há»£p vÃ  ná»™i suy
        for (int i = 0; i < 10; i++) {
            float v1 = OCV_TABLE[i][1];
            float v2 = OCV_TABLE[i+1][1];
            
            if (voltage >= v1 && voltage <= v2) {
                float soc1 = OCV_TABLE[i][0];
                float soc2 = OCV_TABLE[i+1][0];
                
                // Ná»™i suy tuyáº¿n tÃ­nh
                return soc1 + (voltage - v1) * (soc2 - soc1) / (v2 - v1);
            }
        }
        
        // Fallback: giá»¯ nguyÃªn giÃ¡ trá»‹ hiá»‡n táº¡i
        Serial.println("âš ï¸ OCV lookup failed!");
        return soc;
    }
    
    /**
     * Láº¥y há»‡ sá»‘ bÃ¹ nhiá»‡t Ä‘á»™
     */
    float getTempCoeff(float temp) {
        // Giá»›i háº¡n nhiá»‡t Ä‘á»™
        if (temp <= TEMP_COMP_TABLE[0][0]) return TEMP_COMP_TABLE[0][1];  // < -20Â°C
        if (temp >= TEMP_COMP_TABLE[4][0]) return TEMP_COMP_TABLE[4][1];  // > 60Â°C
        
        // Ná»™i suy tuyáº¿n tÃ­nh giá»¯a cÃ¡c Ä‘iá»ƒm
        for (int i = 0; i < 4; i++) {
            float t1 = TEMP_COMP_TABLE[i][0];
            float t2 = TEMP_COMP_TABLE[i+1][0];
            
            if (temp >= t1 && temp <= t2) {
                float a1 = TEMP_COMP_TABLE[i][1];
                float a2 = TEMP_COMP_TABLE[i+1][1];
                
                // Ná»™i suy: Î± = a1 + (temp - t1) Ã— (a2 - a1) / (t2 - t1)
                return a1 + (temp - t1) * (a2 - a1) / (t2 - t1);
            }
        }
        
        return 1.0f;  // Fallback
    }
    
    /**
     * Kiá»ƒm tra vÃ  thá»±c hiá»‡n hiá»‡u chá»‰nh tá»± Ä‘á»™ng
     */
    void autoRecalibrate(float voltage, float current) {
        // ===== PhÃ¡t hiá»‡n tráº¡ng thÃ¡i IDLE =====
        if (abs(current) < I_IDLE_THRESHOLD) {
            if (!isIdle) {
                isIdle = true;
                idleStartTime = millis();
            }
        } else {
            isIdle = false;
        }
        
        unsigned long idleDuration = isIdle ? (millis() - idleStartTime) : 0;
        
        // ===== HIá»†U CHá»ˆNH KHI Äáº¦Y =====
        // Äiá»u kiá»‡n: V >= 14.0V, idle > 30s, khÃ´ng Ä‘ang sáº¡c tÃ­ch cá»±c
        if (voltage >= V_RECALIB_FULL && 
            abs(current) < I_IDLE_THRESHOLD && 
            idleDuration > 30000 &&
            voltage < V_CHARGING) {  // Äáº£m báº£o khÃ´ng Ä‘ang sáº¡c
            
            if (voltage >= V_FULL) {
                // Pin Ä‘Ã£ Ä‘áº§y hoÃ n toÃ n
                if (abs(soc - 100.0f) > 2.0f) {
                    Serial.println("ğŸ”„ Recal: FULL (idle)");
                }
                soc = 100.0f;
                coulombCounter_mAh = CAPACITY_MAH;
            }
        }
        
        // ===== HIá»†U CHá»ˆNH KHI Äáº¦Y (Äang sáº¡c tiáº¿p tá»¥c) =====
        // Äiá»u kiá»‡n: V >= V_FULL, dÃ²ng sáº¡c < 0.2A (gáº§n ngÆ°á»¡ng cáº¯t)
        if (voltage >= V_FULL && 
            current > 0 && 
            current < I_CHARGE_CUTOFF) {
            
            if (abs(soc - 100.0f) > 2.0f) {
                Serial.println("ğŸ”„ Recal: FULL (charging tail)");
            }
            soc = 100.0f;
            coulombCounter_mAh = CAPACITY_MAH;
        }
        
        // ===== HIá»†U CHá»ˆNH KHI Cáº N =====
        // Äiá»u kiá»‡n: V <= 10.4V
        if (voltage <= V_RECALIB_EMPTY) {
            if (voltage <= V_CUTOFF) {
                // Pin gáº§n cáº¡n (cut-off báº£o vá»‡)
                if (abs(soc - 5.0f) > 2.0f) {
                    Serial.println("ğŸ”„ Recal: LOW");
                }
                soc = 5.0f;
                coulombCounter_mAh = CAPACITY_MAH * 0.05f;
            }
            
            // ===== HIá»†U CHá»ˆNH KHI Cáº N HOÃ€N TOÃ€N (Load nhá») =====
            // Äiá»u kiá»‡n: V <= V_EMPTY, dÃ²ng xáº£ < 1A
            if (voltage <= V_EMPTY && abs(current) < I_LOAD_THRESHOLD) {
                if (abs(soc - 0.0f) > 1.0f) {
                    Serial.println("ğŸ”„ Recal: EMPTY (low load)");
                }
                soc = 0.0f;
                coulombCounter_mAh = 0.0f;
            }
        }
        
        // ===== HIá»†U CHá»ˆNH Äá»ŠNH Ká»² Tá»ª OCV =====
        // Khi idle > 30 phÃºt, Ä‘á»“ng bá»™ láº¡i vá»›i OCV
        if (idleDuration > 1800000) {  // 30 phÃºt = 1800000ms
            float ocvSOC = ocvToSOC(voltage);
            float socError = abs(ocvSOC - soc);
            
            if (socError > 5.0f) {  // Sai lá»‡ch > 5%
                Serial.printf("ğŸ”„ OCV Sync: %.1f%% â†’ %.1f%%\n", soc, ocvSOC);
                
                soc = ocvSOC;
                coulombCounter_mAh = (soc / 100.0f) * CAPACITY_MAH;
            }
        }
    }

public:
    // ==================== CONSTRUCTOR ====================
    SOCEstimator(float capacity_ah) 
        : CAPACITY_AH(capacity_ah),
          CAPACITY_MAH(capacity_ah * 1000.0f),
          soc(50.0f),
          coulombCounter_mAh(capacity_ah * 500.0f),
          lastUpdateTime(0),
          initialized(false),
          idleStartTime(0),
          isIdle(false)
    {
    }
    
    // ==================== KHá»I Táº O SOC Tá»ª ÄIá»†N ÃP ====================
    void initializeFromVoltage(float packVoltage) {
        if (initialized) return;
        
        soc = ocvToSOC(packVoltage);
        coulombCounter_mAh = (soc / 100.0f) * CAPACITY_MAH;
        lastUpdateTime = millis();
        initialized = true;
        
        Serial.printf("ğŸ”‹ Init: %.3fV â†’ %.1f%% (%.1fAh)\n", 
                      packVoltage, soc, CAPACITY_AH);
    }
    
    // ==================== Cáº¬P NHáº¬T SOC (COULOMB COUNTING) ====================
    void update(float current_A, float temperature) {
        if (!initialized) {
            Serial.println("âš ï¸ SOC not initialized! Call initializeFromVoltage() first");
            return;
        }
        
        unsigned long now = millis();
        float dt_sec = (now - lastUpdateTime) / 1000.0f;
        lastUpdateTime = now;
        
        // Bá» qua náº¿u dt quÃ¡ lá»›n (láº§n Ä‘áº§u hoáº·c reset)
        if (dt_sec > 10.0f) return;
        
        // ===== Lá»ŒC NHIá»„U DÃ’NG ÄIá»†N =====
        // Loáº¡i bá» noise Â±50mA khi idle
        float filtered_current = current_A;
        if (abs(current_A) < CURRENT_DEADBAND) {
            filtered_current = 0.0f;
        }
        
        // ===== TÃCH LÅ¨Y COULOMB =====
        // DÃ²ng dÆ°Æ¡ng = sáº¡c (+), Ã¢m = xáº£ (-)
        float charge_mAh = filtered_current * 1000.0f * (dt_sec / 3600.0f);
        coulombCounter_mAh += charge_mAh;
        
        // ===== BÃ™ NHIá»†T Äá»˜ VÃ€O DUNG LÆ¯á»¢NG =====
        // TÃ­nh dung lÆ°á»£ng hiá»‡u dá»¥ng theo nhiá»‡t Ä‘á»™
        float tempCoeff = getTempCoeff(temperature);
        float effectiveCapacity_mAh = CAPACITY_MAH * tempCoeff;
        
        // ===== TÃNH SOC Dá»°A TRÃŠN DUNG LÆ¯á»¢NG HIá»†U Dá»¤NG =====
        soc = (coulombCounter_mAh / effectiveCapacity_mAh) * 100.0f;
        
        // ===== GIá»šI Háº N 0-100% =====
        if (soc > 100.0f) {
            soc = 100.0f;
            coulombCounter_mAh = effectiveCapacity_mAh;
        }
        if (soc < 0.0f) {
            soc = 0.0f;
            coulombCounter_mAh = 0.0f;
        }
    }
    
    // ==================== AUTO RECALIBRATION ====================
    void recalibrate(float packVoltage, float current_A) {
        autoRecalibrate(packVoltage, current_A);
    }
    
    // ==================== HIá»†U CHá»ˆNH THá»¦ CÃ”NG ====================
    void reset(float newSOC) {
        soc = constrain(newSOC, 0.0f, 100.0f);
        coulombCounter_mAh = (soc / 100.0f) * CAPACITY_MAH;
    }
    
    // ==================== Láº¤Y SOC HIá»†N Táº I ====================
    float getSOC() const {
        return soc;
    }
    
    // ==================== DEBUG THÃ”NG TIN (TÃ™Y CHá»ŒN) ====================
    void printDebug(float packVoltage, float current_A, float temperature) {
        float ocvSOC = ocvToSOC(packVoltage);
        float tempCoeff = getTempCoeff(temperature);
        float effectiveCapacity = CAPACITY_MAH * tempCoeff;
        
        Serial.println("\nâ•”â•â•â• SOC DEBUG â•â•â•â•—");
        Serial.printf("ğŸ”‹ SOC: %.1f%% | OCV: %.1f%% (Î”%.1f%%)\n", 
                      soc, ocvSOC, abs(soc - ocvSOC));
        Serial.printf("âš¡ %.1f/%.0f mAh (Effective: %.0f mAh)\n", 
                      coulombCounter_mAh, CAPACITY_MAH, effectiveCapacity);
        Serial.printf("ğŸŒ¡ %.1fÂ°C (Î±%.2f) | ", temperature, tempCoeff);
        Serial.printf("ğŸ“¡ %s\n", isIdle ? "IDLE" : "ACTIVE");
        Serial.printf("ğŸ”Œ %+.2fA", current_A);
        
        // Cáº£nh bÃ¡o náº¿u sai sá»‘ lá»›n
        if (abs(soc - ocvSOC) > 10.0f) {
            Serial.println(" âš ï¸  Large error - Check calibration");
        } else {
            Serial.println();
        }
        
        Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    }
};

#endif // SOC_ESTIMATOR_H


C cá»§a soh

if (now - lastSaveTime >= SAVE_INTERVAL) {
    saveToFlash();
    lastSaveTime = now;
}

/**
* LÆ°u dá»¯ liá»‡u vÃ o flash
*/
void saveToFlash() {
    prefs.begin(NAMESPACE, false);
    prefs.putFloat("soh", soh);
    prefs.putFloat("cycles", totalCycles);
    prefs.putFloat("eqCycles", equivalentFullCycles);
    prefs.putFloat("capacity", currentCapacity_Ah);
    prefs.end();
}


// Cáº¥u hÃ¬nh WiFi Access Point
const char* AP_SSID = "ESP32_BMS";           // TÃªn WiFi
const char* AP_PASSWORD = "12345678";        // Máº­t kháº©u
const IPAddress AP_IP(192, 168, 4, 1);       // Äá»‹a chá»‰ IP
const IPAddress AP_GATEWAY(192, 168, 4, 1);  // Gateway
const IPAddress AP_SUBNET(255, 255, 255, 0); // Subnet mask

void setupWebServer() {
    // Root endpoint - HTML Dashboard
    server.on("/", HTTP_GET, []() {
        server.send(200, "text/html", getHTMLPage());
    });
    
    // BMS data JSON API
    server.on("/bms", HTTP_GET, []() {
        server.sendHeader("Access-Control-Allow-Origin", "*");
        server.send(200, "application/json", getBMSJson());
    });
    
    // 404 handler
    server.onNotFound([]() {
        server.send(404, "text/plain", "404: Not Found");
    });
    
    Serial.println("âœ… Web server routes configured");
}

{
  "measurement": {
    "cellVoltages": [
      {"cell": 1, "voltage": "3.654"},
      {"cell": 2, "voltage": "3.652"},
      {"cell": 3, "voltage": "3.655"},
      {"cell": 4, "voltage": "3.653"}
    ],
    "packVoltage": "14.614",
    "current": "0.125",
    "packTemperature": "28.5"
  },
  "calculation": {
    "soc": "85.5",
    "soh": "98.2"
  },
  "status": {
    "charging": "charging",
    "balancing": {
      "active": true,
      "cells": [1, 3]
    }
  },
  "protection": {
    "overVoltage": "normal",
    "underVoltage": "normal",
    "overCurrent": "normal",
    "shortCircuit": "normal",
    "overTemperature": "normal"
  },
  "alerts": [
    {
      "severity": "warning",
      "message": "Cell voltage imbalance detected"
    }
  ]
}